var _ = require('underscore');
var path = require('path');
var fs = require('fs');

var utils = require('./modules/utils');
var compileModule = require('./modules/compile');
var indexModule = require('./modules/index');
var referenceModule = require('./modules/reference');
var amdLoaderModule = require('./modules/amdLoader');
var html2tsModule = require('./modules/html2ts');
var templateCacheModule = require('./modules/templateCache');

var Promise = require('es6-promise').Promise;

function timeIt(makeIt) {
    var starttime = new Date().getTime();
    var it = makeIt();
    var endtime = new Date().getTime();
    return {
        it: it,
        time: endtime - starttime
    };
}

function asyncSeries(arr, iter) {
    arr = arr.slice(0);

    var memo = [];

    return new Promise(function (resolve, reject) {
        var next = function () {
            if (arr.length === 0) {
                resolve(memo);
                return;
            }
            Promise.cast(iter(arr.shift())).then(function (res) {
                memo.push(res);
                next();
            }, reject);
        };
        next();
    });
}

function pluginFn(grunt) {
    grunt.registerMultiTask('ts', 'Compile TypeScript files', function () {
        var currenttask = this;

        var done = currenttask.async();

        var watch;

        var options = currenttask.options({
            allowBool: false,
            allowImportModule: false,
            compile: true,
            declaration: false,
            mapRoot: '',
            module: 'amd',
            noImplicitAny: false,
            noResolve: false,
            comments: null,
            removeComments: null,
            sourceMap: true,
            sourceRoot: '',
            target: 'es5',
            verbose: false,
            fast: 'watch'
        });

        options.allowBool = 'allowbool' in options ? options['allowbool'] : options.allowBool;
        options.allowImportModule = 'allowimportmodule' in options ? options['allowimportmodule'] : options.allowImportModule;
        options.sourceMap = 'sourcemap' in options ? options['sourcemap'] : options.sourceMap;

        if (options.fast !== 'watch' && options.fast !== 'always' && options.fast !== 'never') {
            console.warn(('"fast" needs to be one of : "watch" (default) | "always" | "never" but you provided: ' + options.fast).magenta);
            options.fast = 'watch';
        }

        if (options.removeComments === null) {
            options.removeComments = !options.comments;
        } else if (options.comments !== null) {
            console.warn('WARNING: Option "comments" and "removeComments" should not be used together'.magenta);
            if (options.removeComments === options.comments) {
                console.warn('Either option will suffice (and removing the other will have no effect).'.magenta);
            } else {
                console.warn(('The --removeComments value of "' + options.removeComments + '" ' + 'supercedes the --comments value of "' + options.comments + '"').magenta);
            }
        }
        options.removeComments = !!options.removeComments;

        asyncSeries(this.files, function (target) {
            var reference = target.reference;
            var referenceFile;
            var referencePath;
            if (!!reference) {
                referenceFile = path.resolve(reference);
                referencePath = path.dirname(referenceFile);
            }
            function isReferenceFile(filename) {
                return path.resolve(filename) === referenceFile;
            }

            var out = target.out;
            var outFile;
            var outFile_d_ts;
            if (!!out) {
                outFile = path.resolve(out);
                outFile_d_ts = outFile.replace('.js', '.d.ts');
            }
            function isOutFile(filename) {
                return path.resolve(filename) === outFile_d_ts;
            }

            function isBaseDirFile(filename, targetFiles) {
                var baseDirFile = '.baseDir.ts';
                if (!target.baseDir) {
                    target.baseDir = utils.findCommonPath(targetFiles, '/');
                }
                return path.resolve(filename) === path.resolve(path.join(target.baseDir, baseDirFile));
            }

            var amdloader = target.amdloader;
            var amdloaderFile;
            var amdloaderPath;
            if (!!amdloader) {
                amdloaderFile = path.resolve(amdloader);
                amdloaderPath = path.dirname(amdloaderFile);
            }

            function runCompilation(files, target, options) {
                grunt.log.writeln('Compiling...'.yellow);

                var filesToCompile = files;

                var starttime = new Date().getTime();
                var endtime;

                return compileModule.compileAllFiles(filesToCompile, target, options).then(function (result) {
                    endtime = new Date().getTime();

                    if (!result || result.code) {
                        grunt.log.error('Compilation failed'.red);
                        return false;
                    } else {
                        var time = (endtime - starttime) / 1000;
                        grunt.log.writeln(('Success: ' + time.toFixed(2) + 's for ' + result.fileCount + ' typescript files').green);
                        return true;
                    }
                });
            }

            function filterFilesAndCompile() {
                var files = grunt.file.expand(currenttask.data.src);

                files = files.filter(function (file) {
                    var stats = fs.lstatSync(file);
                    return !stats.isDirectory();
                });

                files = _.filter(files, function (filename) {
                    return (!isReferenceFile(filename) && !isOutFile(filename) && !isBaseDirFile(filename, files));
                });

                var generatedFiles = [];
                if (currenttask.data.html) {
                    var htmlFiles = grunt.file.expand(currenttask.data.html);
                    generatedFiles = _.map(htmlFiles, function (filename) {
                        return html2tsModule.compileHTML(filename);
                    });
                }

                if (currenttask.data.templateCache) {
                    if (!currenttask.data.templateCache.src || !currenttask.data.templateCache.dest || !currenttask.data.templateCache.baseUrl) {
                        grunt.log.writeln('templateCache : src, dest, baseUrl must be specified if templateCache option is used'.red);
                    } else {
                        var templateCacheSrc = grunt.file.expand(currenttask.data.templateCache.src);
                        var templateCacheDest = path.resolve(target.templateCache.dest);
                        var templateCacheBasePath = path.resolve(target.templateCache.baseUrl);
                        templateCacheModule.generateTemplateCache(templateCacheSrc, templateCacheDest, templateCacheBasePath);
                    }
                }

                if (target.index) {
                    if (!_.isArray(target.index)) {
                        grunt.warn('Index option needs to be an array of directories');
                    }
                    indexModule.indexDirectories(_.map(target.index, function (folder) {
                        return path.resolve(folder);
                    }));
                }

                if (!!referencePath) {
                    var result = timeIt(function () {
                        return referenceModule.updateReferenceFile(files, generatedFiles, referenceFile, referencePath);
                    });
                    if (result.it === true) {
                        grunt.log.writeln(('Updated reference file (' + result.time + 'ms).').green);
                    }
                }

                if (!!amdloaderPath) {
                    var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);
                    amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, target.outDir);
                }

                if (options.compile) {
                    if (files.length > 0) {
                        return runCompilation(files, target, options).then(function (success) {
                            return success;
                        });
                    } else {
                        grunt.log.writeln('No files to compile'.red);
                        return Promise.resolve(true);
                    }
                } else {
                    return Promise.resolve(true);
                }
            }

            var lastCompile = 0;

            watch = target.watch;
            if (!!watch) {
                function handleFileEvent(filepath, displaystr, addedOrChanged) {
                    if (typeof addedOrChanged === "undefined") { addedOrChanged = false; }
                    if (!utils.endsWith(filepath.toLowerCase(), '.ts') && !utils.endsWith(filepath.toLowerCase(), '.html')) {
                        return;
                    }

                    if ((new Date().getTime() - lastCompile) <= 100) {
                        return;
                    }

                    grunt.log.writeln((displaystr + ' >>' + filepath).yellow);

                    filterFilesAndCompile();
                }

                var watchpath = path.resolve(watch);

                var chokidar = require('chokidar');
                var watcher = chokidar.watch(watchpath, { ignoreInitial: true, persistent: true });

                grunt.log.writeln(('Watching all TypeScript / Html files under : ' + watchpath).cyan);

                watcher.on('add', function (path) {
                    handleFileEvent(path, '+++ added   ', true);

                    lastCompile = new Date().getTime();
                }).on('change', function (path) {
                    handleFileEvent(path, '### changed ', true);

                    lastCompile = new Date().getTime();
                }).on('unlink', function (path) {
                    handleFileEvent(path, '--- removed ');

                    lastCompile = new Date().getTime();
                }).on('error', function (error) {
                    console.error('Error happened in chokidar: ', error);
                });
            }

            lastCompile = new Date().getTime();

            return filterFilesAndCompile();
        }).then(function (res) {
            if (!watch) {
                if (res.some(function (succes) {
                    return !succes;
                })) {
                    done(false);
                } else {
                    done();
                }
            }
        }, done);
    });
}
module.exports = pluginFn;
//# sourceMappingURL=ts.js.map
