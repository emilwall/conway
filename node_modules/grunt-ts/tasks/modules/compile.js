var path = require('path');
var fs = require('fs');
var _ = require('underscore');
var utils = require('./utils');
var cache = require('./cacheUtils');
var transformers = require('./transformers');

var Promise = require('es6-promise').Promise;
exports.grunt = require('grunt');

function executeNode(args) {
    return new Promise(function (resolve, reject) {
        exports.grunt.util.spawn({
            cmd: 'node',
            args: args
        }, function (error, result, code) {
            var ret = {
                code: code,
                output: String(result)
            };
            resolve(ret);
        });
    });
}

var cacheClearedOnce = {};

function getChangedFiles(files) {
    var targetName = exports.grunt.task.current.target;

    files = cache.getNewFilesForTarget(files, targetName);

    _.forEach(files, function (file) {
        exports.grunt.log.writeln(('### Fast Compile >>' + file).cyan);
    });

    return files;
}

function resetChangedFiles(files) {
    var targetName = exports.grunt.task.current.target;
    cache.compileSuccessfull(files, targetName);
}

function clearCache() {
    var targetName = exports.grunt.task.current.target;
    cache.clearCache(targetName);
    cacheClearedOnce[targetName] = true;
}

function resolveTypeScriptBinPath() {
    var ownRoot = path.resolve(path.dirname((module).filename), '../..');
    var userRoot = path.resolve(ownRoot, '..', '..');
    var binSub = path.join('node_modules', 'typescript', 'bin');

    if (fs.existsSync(path.join(userRoot, binSub))) {
        return path.join(userRoot, binSub);
    }
    return path.join(ownRoot, binSub);
}

function getTsc(binPath) {
    var pkg = JSON.parse(fs.readFileSync(path.resolve(binPath, '..', 'package.json')).toString());
    exports.grunt.log.writeln('Using tsc v' + pkg.version);

    return path.join(binPath, 'tsc');
}

function compileAllFiles(targetFiles, target, task) {
    var files = _.map(targetFiles, function (file) {
        return file;
    });

    var newFiles = files;
    if (task.fast === 'watch') {
        if (cacheClearedOnce[exports.grunt.task.current.target] === undefined) {
            clearCache();
        }
    }
    if (task.fast !== 'never') {
        if (target.out) {
            exports.grunt.log.writeln('Fast compile will not work when --out is specified. Ignoring fast compilation'.cyan);
        } else {
            newFiles = getChangedFiles(files);

            if (newFiles.length !== 0) {
                files = newFiles;

                if (target.outDir && !target.baseDir) {
                    target.baseDir = utils.findCommonPath(files, '/');
                }
            } else {
                exports.grunt.log.writeln('No file changes were detected. Skipping Compile'.green);
                return new Promise(function (resolve) {
                    var ret = {
                        code: 0,
                        fileCount: 0,
                        output: 'No files compiled as no change detected'
                    };
                    resolve(ret);
                });
            }
        }
    }

    transformers.transformFiles(newFiles, targetFiles, target, task);

    var baseDirFile = '.baseDir.ts';
    var baseDirFilePath;
    if (target.outDir && target.baseDir && files.length > 0) {
        baseDirFilePath = path.join(target.baseDir, baseDirFile);
        if (!fs.existsSync(baseDirFilePath)) {
            exports.grunt.file.write(baseDirFilePath, '// Ignore this file. See https://github.com/grunt-ts/grunt-ts/issues/77');
        }
        files.push(baseDirFilePath);
    }

    if (target.reference && target.out) {
        var referenceFile = path.resolve(target.reference);
        files = [referenceFile];
    }

    files = _.map(files, function (item) {
        return '"' + path.resolve(item) + '"';
    });

    var args = files.slice(0);

    if (task.sourceMap) {
        args.push('--sourcemap');
    }
    if (task.declaration) {
        args.push('--declaration');
    }
    if (task.removeComments) {
        args.push('--removeComments');
    }
    if (task.noImplicitAny) {
        args.push('--noImplicitAny');
    }
    if (task.noResolve) {
        args.push('--noResolve');
    }

    args.push('--target', task.target.toUpperCase());
    args.push('--module', task.module.toLowerCase());

    if (target.out) {
        args.push('--out', target.out);
    }
    if (target.outDir) {
        if (target.out) {
            console.warn('WARNING: Option "out" and "outDir" should not be used together'.magenta);
        }
        args.push('--outDir', target.outDir);
    }
    if (task.sourceRoot) {
        args.push('--sourceRoot', task.sourceRoot);
    }
    if (task.mapRoot) {
        args.push('--mapRoot', task.mapRoot);
    }

    var tsc = getTsc(resolveTypeScriptBinPath());

    if (task.verbose) {
        console.log(args.join(' ').yellow);
    } else {
        exports.grunt.log.verbose.writeln(args.join(' ').yellow);
    }

    var tempfilename = utils.getTempFile('tscommand');
    if (!tempfilename) {
        throw (new Error('cannot create temp file'));
    }

    fs.writeFileSync(tempfilename, args.join(' '));

    return executeNode([tsc, '@' + tempfilename]).then(function (result) {
        if (task.fast !== 'never' && result.code === 0) {
            resetChangedFiles(newFiles);
        }

        result.fileCount = files.length;

        fs.unlinkSync(tempfilename);

        exports.grunt.log.writeln(result.output);

        return Promise.cast(result);
    }, function (err) {
        fs.unlinkSync(tempfilename);
        throw err;
    });
}
exports.compileAllFiles = compileAllFiles;
//# sourceMappingURL=compile.js.map
